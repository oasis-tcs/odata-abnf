---
#------------------------------------------------------------------------------
# OData Aggregation ABNF Test Cases Version 4.0
#------------------------------------------------------------------------------
# 16 December 2021
#------------------------------------------------------------------------------
#
# Technical Committee:
#   OASIS Open Data Protocol (OData) TC
#   https://www.oasis-open.org/committees/odata
#
# Chairs:
#   - Ralf Handl (ralf.handl@sap.com), SAP SE
#   - Michael Pizzo (mikep@microsoft.com), Microsoft
#
# Editors:
#   - Ralf Handl (ralf.handl@sap.com), SAP SE
#   - Hubert Heijkers (hubert.heijkers@nl.ibm.com), IBM
#   - Gerald Krause (gerald.krause@sap.com), SAP SE
#   - Michael Pizzo (mikep@microsoft.com), Microsoft
#   - Martin Zurmuehl (martin.zurmuehl@sap.com), SAP SE
#   - Heiko Theissen (heiko.theissen@sap.com), SAP SE
#
# Additional artifacts:
#   This test case document is one component of a Work Product which consists of:
#   - OData Extension for Data Aggregation Version 4.0
#   - OData Aggregation Vocabulary
#   - OData Aggregation ABNF Construction Rules Version 4.0
#   - OData Aggregation ABNF Test Cases (this document)
#
# Related work:
#   This specification is related to:
#   - OData Version 4.01 Part 1: Protocol
#   - OData Version 4.01 Part 2: URL Conventions
#   - OData ABNF Construction Rules Version 4.01
#   - OData ABNF Test Cases Version 4.01
#   - OData Common Schema Definition Language (CSDL) JSON Representation Version 4.01
#   - OData Common Schema Definition Language (CSDL) XML Representation Version 4.01
#   - OData JSON Format Version 4.01
#   This specification replaces or supersedes:
#   - None
#
# Declared XML namespaces:
#   - None
#
# Abstract:
#   This specification adds basic grouping and aggregation functionality (such as
#   sum, min, and max) to the Open Data Protocol (OData) without changing any
#   of the base principles of OData.
#
#
# Overview:
#   This document contains positive and negative test cases for the
#   OData Aggregation ABNF Construction Rules Version 4.0.
#   Positive test cases consist of the rule to test, the input string to parse,
#   and a description of the test case.
#   Negative test cases in addition state the character position at which the
#   invalid portion of input text starts, 0 meaning the whole input string.
#
#   These test cases can be automatically executed with the ABNF test tool
#   available at https://github.com/oasis-tcs/odata-abnf/tree/main/lib.
#   This tool is neither required for interpreting the test cases, nor is it
#   part of the OData work product.
#
# ------------------------------------------------------------------------------

Constraints:
  action: []
  actionImport: []
  expressionAlias:
    - Actual
    - AverageAmount
    - AveragePrice
    - AvgAmt
    - CountryPopulation
    - CustomerAmount
    - CustomerCountryAverage
    - CustomerYearAmount
    - CustomerIDs
    - DailyAverage
    - Detail
    - DistinctProducts
    - FilteredSales
    - FilteredSuppliers
    - FirstLetter
    - ItemAmount
    - MaxAmount
    - MinAmount
    - MonthlyAverage
    - NumberOfLeaves
    - ProductNames
    - ProductIDs
    - Profit
    - RelativeAmount
    - RelativeOrderSize
    - RegionAmount
    - RevenueContribution
    - RevenueTrend
    - Sale
    - SalesCount
    - SomeCustomers
    - Stuff
    - PaperSalesCount
    - SalesOrgCount
    - Tax
    - Total
    - TotalAmount
    - TotalPlannedRevenue
    - TotalPopulation
    - TotalSales
    - WeekDay
  complexColProperty:
    - Details
  complexColFunction:
    - condense
  complexColFunctionImport: []
  complexFunction: []
  complexFunctionImport: []
  complexProperty:
    - ShipTo
  complexTypeName: []
  customAggregate:
    - Budget
    - Forecast
  entityColFunction:
    - TopCountAndBalance
  entityColFunctionImport: []
  entityColNavigationProperty:
    - Items
    - Nodes
    - Orders
    - Products
    - Sales
    - SalesPlan
    - Suppliers
  entityFunction: []
  entityFunctionImport: []
  entityNavigationProperty:
    - Category
    - Continent
    - Country
    - Currency
    - Customer
    - Product
    - Products_cj
    - ProductGroup
    - Sales_cj
    - Time
    - TotalSales
  entitySetName:
    - Categories
    - Customers
    - Products
    - Products_cj
    - Sales
    - Sales_cj
    - SalesOrganizations
    - SalesOrgHierarchies
    - Time
  entityTypeName: []
  enumerationMember: []
  enumerationTypeName: []
  keyPathLiteral: []
  keyPropertyAlias: []
  lambdaVariableExpr:
    - p
  namespacePart:
    - Aggregation
    - Custom
    - Self
  primitiveColFunction: []
  primitiveColFunctionImport: []
  primitiveColProperty: []
  primitiveFunction:
    - isroot
    - isleaf
    - isancestor
    - issibling
    - isdescendant
  primitiveFunctionImport: []
  primitiveKeyProperty:
    - Code
    - Date
    - ID
  primitiveNonKeyProperty:
    - Amount
    - City
    - Cost
    - CountryCode
    - Region
    - Month
    - Name
    - PlannedRevenue
    - Population
    - Price
    - ProductID
    - Quantity
    - Revenue
    - SalesArea
    - SalesNumber
    - Shipped
    - Status
    - Street
    - TaxRate
    - Year
  streamProperty: []

TestCases:
  - Name: aggregate - no parameters
    Rule: queryOptions
    FailAt: 17
    Input: $apply=aggregate()

  - Name: aggregate - property with method as alias
    Rule: queryOptions
    Input: $apply=aggregate(Amount with sum as Total)

  - Name: aggregate - alias - context URL
    Rule: odataRelativeUri
    Input: $metadata#Sales(Total)

  - Name: aggregate - property requires alias
    Rule: queryOptions
    FailAt: 32
    Input: $apply=aggregate(Amount with sum)

  - Name: aggregate - property requires method
    Rule: queryOptions
    FailAt: 24
    Input: $apply=aggregate(Amount as Total)

  - Name: aggregate - property requires method and alias
    Rule: queryOptions
    FailAt: 23
    Input: $apply=aggregate(Amount)

  - Name: aggregate - expression
    Rule: queryOptions
    Input: $apply=aggregate(Amount mul Product/TaxRate with sum as Tax)

  - Name: aggregate - no expression after path - this feature from CS02 has been removed
    Rule: queryOptions
    FailAt: 29
    Input: $apply=aggregate(Sales(Amount mul Product/TaxRate with sum as Tax))

  - Name: aggregate - alias - context URL
    Rule: odataRelativeUri
    Input: $metadata#Products(Sales(Tax))

  - Name: aggregate - min
    Rule: queryOptions
    Input: $apply=aggregate(Amount with max as MaxAmount)

  - Name: aggregate - max
    Rule: queryOptions
    Input: $apply=aggregate(Amount with max as MaxAmount)

  - Name: aggregate - average
    Rule: queryOptions
    Input: $apply=aggregate(Amount with average as AverageAmount)

  - Name: aggregate - custom aggregation method
    Rule: queryOptions
    Input: $apply=aggregate(Product/Name with Custom.concat as ProductNames)

  - Name: aggregate - countdistinct
    Rule: queryOptions
    Input: $apply=aggregate(Product with countdistinct as DistinctProducts)

  - Name: aggregate - from
    Rule: queryOptions
    Input: $apply=aggregate(Amount with sum from Time with average as DailyAverage)

  - Name: aggregate - from twice
    Rule: queryOptions
    Input:
      $apply=aggregate(Amount with sum from Time with average from Product/Name
      with max as DailyAverage)

  - Name: aggregate - from requires as
    Rule: queryOptions
    FailAt: 55
    Input: $apply=aggregate(Amount with sum from Time with average)

  - Name: aggregate - property from requires with
    Rule: queryOptions
    FailAt: 24
    Input: $apply=aggregate(Amount from Time with average as DailyAverage)

  - Name: aggregate - custom aggregate reached via path
    Rule: queryOptions
    Input: $apply=aggregate(Sales/Forecast)

  - Name: aggregate - custom aggregate and from
    Rule: queryOptions
    Input: $apply=aggregate(Forecast from Time with average as DailyAverage)

  - Name: aggregate - path with key segment
    Rule: queryOptions
    Input: $apply=aggregate(Product/SalesPlan('2015')/PlannedRevenue with sum as
      TotalPlannedRevenue)

  - Name: aggregate - $count
    Rule: queryOptions
    Input: $apply=aggregate($count as SalesCount)

  - Name: aggregate - $count does not allow with
    Rule: queryOptions
    FailAt: 24
    Input: $apply=aggregate($count with sum as SalesCount)

  - Name: aggregate - topcount
    Rule: queryOptions
    Input: $apply=topcount(2,Amount)

  - Name: aggregate - topsum
    Rule: queryOptions
    Input: $apply=topsum(15,Amount)

  - Name: aggregate - toppercent
    Rule: queryOptions
    Input: $apply=toppercent(50,Amount)

  - Name: aggregate - bottomcount
    Rule: queryOptions
    Input: $apply=bottomcount(2,Amount)

  - Name: aggregate - bottomsum
    Rule: queryOptions
    Input: $apply=bottomsum(15,Amount)

  - Name: aggregate - bottompercent
    Rule: queryOptions
    Input: $apply=bottompercent(50,Amount)

  - Name: aggregate - identity
    Rule: queryOptions
    Input: $apply=identity

  - Name: aggregate - concat
    Rule: queryOptions
    Input: $apply=concat(topcount(2,Amount),bottomcount(2,Amount))

  - Name: aggregate - groupby
    Rule: queryOptions
    Input:
      $apply=groupby((Customer/Country,Product/Name),aggregate(Amount with sum
      as Total))

  - Name: aggregate - groupby distinct
    Rule: queryOptions
    Input: $apply=groupby((Product/Name,Amount))

  - Name: aggregate - groupby with custom aggregates calculated from aggregated
      instances
    Rule: queryOptions
    Input: $apply=groupby((Country),aggregate(Budget))/filter(Budget gt
      1000)/aggregate(Budget)

  - Name: aggregate - groupby rollup leveled hierarchy
    Rule: queryOptions
    Input:
      $apply=groupby((rollup(Customer/Country,Customer/Name),rollup(Product/ProductGroup/Name,Product/Name),Currency/Code),aggregate(Amount
      with sum as Total))

  - Name: aggregate - groupby rollup recursive hierarchy
    Rule: queryOptions
    Input: $apply=groupby((rollup(SalesOrgHierarchy)),aggregate($count as
      SalesOrgCount))

  - Name: aggregate - filter
    Rule: queryOptions
    Input: $apply=filter(Amount gt 3)

  - Name: aggregate - filter on $root
    Rule: queryOptions
    Input: $apply=filter(Name eq Products('P2')/Name)

  - Name: aggregate - search
    Rule: queryOptions
    Input: $apply=search(coffee)

  - Name: aggregate - transformnested
    Rule: queryOptions
    Input: $apply=transformnested(Sales,filter(Amount gt 3))

  - Name: aggregate - transformnested with alias
    Rule: queryOptions
    FailAt: 49
    Input: $apply=transformnested(Sales,filter(Amount gt 3) as FilteredSales)

  - Name: aggregate - transformnested multiple
    Rule: queryOptions
    FailAt: 48
    Input: $apply=transformnested(Sales,filter(Amount gt 3),filter(Amount lt 3))

  - Name: aggregate - addnested
    Rule: queryOptions
    Input: $apply=addnested(Sales,filter(Amount gt 3) as FilteredSales)

  - Name: aggregate - nesting complex property
    Rule: queryOptions
    Input: $apply=transformnested(ShipTo,identity)

  - Name: aggregate - nesting collection-valued complex property
    Rule: queryOptions
    Input: $apply=transformnested(Details,filter(Cost gt 1000))

  - Name: aggregate - multi-level nest
    Rule: queryOptions
    Input: $apply=transformnested(Products,transformnested(Sales,filter(Amount gt 3)))

  - Name: aggregate - multi-level nest with branches
    Rule: queryOptions
    Input:
      $apply=addnested(Products,transformnested(Sales,filter(Amount gt 3)) as
      FilteredSales,transformnested(Suppliers,transformnested(Products,filter(true))) as
      FilteredSuppliers)

  - Name: aggregate - multi-level nest with branches
    Rule: queryOptions
    FailAt: 68
    Input: $apply=addnested(Products,transformnested(Sales,filter(Amount gt
      3)),transformnested(Suppliers,filter(true),nest(Products)))

  - Name: aggregate - multi-level nest with branches
    Rule: queryOptions
    FailAt: 125
    Input:
      $apply=addnested(Products,transformnested(Sales,filter(Amount gt 3)) as
      FilteredSales,transformnested(Suppliers,nest(Products)))

  - Name: aggregate - nest with filter on $this
    Rule: queryOptions
    Input: $apply=transformnested(Sales,filter($this/Customer/City eq ShipTo/City))

  - Name: aggregate - nest without path
    Rule: queryOptions
    Input:
      $apply=nest(groupby((Customer/ID)) as CustomerIDs,groupby((Product/ID))
      as ProductIDs)

  - Name: aggregate - join
    Rule: queryOptions
    Input: $apply=join(Sales as Sale)

  - Name: aggregate - join
    Rule: queryOptions
    Input: $apply=join(Sales as Sale,filter(Customer/Country eq 'US'))

  - Name: aggregate - join with collection-valued complex property
    Rule: queryOptions
    Input: $apply=join(Details as Detail,filter(Cost gt 1000))

  - Name: aggregate - join with single-valued complex property
    Rule: queryOptions
    FailAt: 18
    Input: $apply=join(ShipTo as Detail,identity)

  - Name: aggregate - join
    Rule: queryOptions
    Input: $apply=outerjoin(Sales as Sale)

  - Name: aggregate - join
    Rule: queryOptions
    Input: $apply=outerjoin(Sales as Sale,filter(Customer/Country eq 'FR'))

  - Name: aggregate - isdefined
    Rule: queryOptions
    Input: $filter=isdefined(Product) and isdefined(Customer/Name) and
      isdefined(Forecast)

  - Name: "aggregate - isdefined: get totals last"
    Rule: queryOptions
    Input: $orderby=isdefined(Product) desc,Product asc

  - Name: aggregate function - after grouping
    Rule: queryOptions
    Input: $apply=groupby((Customer),aggregate(Amount with sum as
      CustomerAmount))/compute(CustomerAmount div $these/aggregate(p:CustomerAmount with
      sum) as RevenueContribution)

  - Name: aggregate function - within a group
    Rule: queryOptions
    Input: $apply=groupby((Customer,Year),aggregate(Amount with sum as
      CustomerYearAmount))/groupby((Customer),compute(CustomerYearAmount div
      $these/aggregate(p:CustomerYearAmount with sum) as RevenueTrend))

  - Name: aggregate function - missing $these
    Rule: queryOptions
    FailAt: 35
    Input: $apply=compute(Amount div aggregate(p:Amount with average) as
      RelativeOrderSize)

  - Name: aggregate function - missing lambda variable
    Rule: queryOptions
    FailAt: 49
    Input: $apply=compute(Amount div $these/aggregate(Amount with average) as
      RelativeOrderSize)

  - Name: aggregate function - across input set
    Rule: queryOptions
    Input: $apply=compute(Amount div $these/aggregate(p:Amount with average) as
      RelativeOrderSize)

  - Name: aggregate function - across input set with custom aggregate
    Rule: queryOptions
    Input: $apply=compute(Amount div $these/aggregate(p:Budget) as RelativeAmount)

  - Name: aggregate function - across input set with related custom aggregate
    Rule: queryOptions
    Input: $apply=compute(Amount div $these/aggregate(p:Product/Budget) as
      RelativeAmount)

  - Name: aggregate function - across input set with from
    Rule: queryOptions
    Input:
      $apply=compute(Amount div $these/aggregate(p:Amount with sum from Time
      with average) as RelativeAmount)

  - Name: aggregate function - across input set with $count
    Rule: queryOptions
    Input: $apply=compute($these/aggregate(p:$count) as SalesCount)

  - Name: aggregate function - across input set with $count
    Rule: queryOptions
    Input: $apply=groupby((Customer),compute($these/aggregate(p:$count) as
      SalesCount))/filter(SalesCount ge 2)/aggregate(Amount with sum as
      TotalAmount)

  - Name: aggregate function - within a group - ...
    Rule: queryOptions
    Input: $apply=groupby((Region),compute($these/aggregate(p:SalesNumber with
      average) as RegionAmount))/filter(RegionAmount gt
      150)/concat(groupby((Region),aggregate(SalesNumber with average as
      RegionAmount)),aggregate(SalesNumber with average as TotalAmount))

  - Name: aggregate function - in $compute option
    Rule: queryOptions
    Input: $compute=Amount div $these/aggregate(p:Amount with sum) as RelativeAmount

  - Name: aggregate function - in $compute option with custom aggregate
    Rule: queryOptions
    Input: $compute=Amount div $these/aggregate(p:Budget) as RelativeAmount

  - Name: aggregate function - within filter and lambda
    Rule: queryOptions
    Input: $filter=Products/aggregate(p:p/Sales/Amount with sum) gt 3

  - Name: aggregate - crossjoin
    Rule: odataRelativeUri
    Input: $crossjoin(Products_cj,Sales_cj)?$apply=filter(Products_cj/ID eq
      Sales_cj/ProductID)/groupby((Products_cj/Name),aggregate(Sales_cj/Amount
      with sum as Total))

  - Name: aggregate - crossjoin
    Rule: odataRelativeUri
    Input: $crossjoin(Products_cj,Time,Sales_cj)?$apply=groupby((Products_cj/Name,Time/Date),aggregate(Budget))

  - Name: aggregate - custom aggregate with path on crossjoin
    Rule: odataRelativeUri
    Input: $crossjoin(Products_cj,Time,Sales_cj)?$apply=groupby((Products_cj/Name,Time/Date),aggregate(Sales_cj/Forecast))

  - Name: custom aggregates - entity set
    Rule: odataRelativeUri
    Input: Sales?$apply=groupby((Time/Month),aggregate(Forecast))

  - Name: custom aggregates - crossjoin
    Rule: odataRelativeUri
    Input: $crossjoin(Time)?$apply=groupby((Time/Year),aggregate(Budget))

  - Name: hierarchy functions - isroot
    Rule: odataRelativeUri
    Input: SalesOrganizations?$filter=$it/Aggregation.isroot(Hierarchy='SalesOrgHierarchy')

  - Name: hierarchy functions - isdescendant
    Rule: odataRelativeUri
    Input: SalesOrganizations?$filter=$it/Aggregation.isdescendant(Hierarchy='SalesOrgHierarchy',Node='EMEA')

  - Name: hierarchy functions - isdescendant
    Rule: odataRelativeUri
    Input: SalesOrganizations?$filter=$it/Aggregation.isdescendant(Hierarchy='SalesOrgHierarchy',Node='EMEA',MaxDistance=1)

  - Name: hierarchy functions - isancestor
    Rule: odataRelativeUri
    Input: SalesOrganizations?$filter=$it/Aggregation.isancestor(Hierarchy='SalesOrgHierarchy',Node='EMEA')

  - Name: hierarchy functions - isancestor
    Rule: odataRelativeUri
    Input: SalesOrganizations?$filter=$it/Aggregation.isancestor(Hierarchy='SalesOrgHierarchy',Node='EMEA',MaxDistance=1)

  - Name: hierarchy functions - issibling
    Rule: odataRelativeUri
    Input: SalesOrganizations?$filter=$it/Aggregation.issibling(Hierarchy='SalesOrgHierarchy',Node='EMEA')

  - Name: hierarchy functions - isleaf
    Rule: odataRelativeUri
    Input: SalesOrganizations?$filter=$it/Aggregation.isleaf(Hierarchy='SalesOrgHierarchy')

  - Name: hierarchy transformations - ancestors
    Rule: queryOptions
    Input: $apply=ancestors($root/SalesOrganizations,SalesOrgHierarchy,ID,contains(Name,'East') or
      contains(Name,'Central'))

  - Name: hierarchy transformations - ancestors
    Rule: queryOptions
    Input: $apply=ancestors($root/SalesOrganizations,SalesOrgHierarchy,ID,contains(Name,'East') or
      contains(Name,'Central'), 2)

  - Name: hierarchy transformations - ancestors
    Rule: queryOptions
    Input: $apply=ancestors($root/SalesOrgHierarchies('DEFAULT')/Nodes,SalesOrgHierarchy,ID,contains(Name,'East') or
      contains(Name,'Central'), keep start)

  - Name: hierarchy transformations - ancestors
    Rule: queryOptions
    Input: $apply=ancestors($root/SalesOrganizations,SalesOrgHierarchy,ID,contains(Name,'East') or
      contains(Name,'Central'), 2, keep start)

  - Name: hierarchy transformations - descendants
    Rule: queryOptions
    Input: $apply=descendants($root/SalesOrganizations,SalesOrgHierarchy,ID,Name eq 'US')

  - Name: hierarchy transformations - descendants
    Rule: queryOptions
    Input: $apply=descendants($root/SalesOrganizations,SalesOrgHierarchy,ID,Name eq 'US', 3)

  - Name: hierarchy transformations - descendants
    Rule: queryOptions
    Input: $apply=descendants($root/SalesOrganizations,SalesOrgHierarchy,ID,Name eq 'US',3,keep start)

  - Name: hierarchy transformations - traverse
    Rule: queryOptions
    Input: $apply=traverse(SalesOrgHierarchy,preorder)

  - Name: distinct values - no aggregate
    Rule: odataRelativeUri
    Input: Customers?$apply=groupby((Name))

  - Name: distinct values - navigation
    Rule: queryOptions
    Input: $apply=groupby((Customer/Name))

  - Name: distinct values - two grouping properties
    Rule: queryOptions
    Input: $apply=groupby((Customer/Name,Customer/ID))

  - Name: distinct values - three grouping properties
    Rule: queryOptions
    Input: $apply=groupby((Customer/Name,Customer/ID,Product/Name))

  - Name: aggregation methods
    Rule: queryOptions
    Input: $apply=groupby((Name),aggregate(Amount with sum as Total))

  - Name: aggregation methods - multiple grouping
    Rule: queryOptions
    Input: $apply=groupby((Country,Name),aggregate(Amount with sum as Total))

  - Name: aggregation methods - multiple grouping - distinct
    Rule: queryOptions
    Input: $apply=groupby((Customer,Product/Name))

  - Name: aggregation methods - collection-valued navigation property
    Rule: queryOptions
    FailAt: 21
    Input: $apply=groupby((Sales/Product/Name))

  - Name: aggregation methods - average
    Rule: queryOptions
    Input: $apply=groupby((Customer/Country),aggregate(Amount with average as
      AverageAmount))

  - Name: aggregation methods - $count segment
    Rule: queryOptions
    Input: $apply=groupby((Name),aggregate(Sales/$count with sum as SalesCount))

  - Name: aggregation methods - $count segment and sum
    Rule: queryOptions
    Input: $apply=groupby((Name),aggregate(Sales/$count with sum as
      SalesCount,Sales/Amount with sum as Total))

  - Name:
      aggregation methods - $count only allowed on top level, not nested within
      path
    Rule: queryOptions
    FailAt: 38
    Input: $apply=groupby((Name),aggregate(Sales($count as SalesCount)))

  - Name: collection-valued path
    Rule: queryOptions
    Input: $apply=groupby((Name),aggregate(Sales/Amount with sum as Total))

  - Name: custom aggregate
    Rule: queryOptions
    Input: $apply=groupby((Customer/Country),aggregate(Amount with sum as
      Actual,Forecast))

  - Name: custom aggregate reached via path
    Rule: queryOptions
    Input: $apply=groupby((Name),aggregate(Sales/Forecast))

  - Name: aliasing - aggregate with two parameters
    Rule: queryOptions
    Input: $apply=groupby((Customer/Country),aggregate(Amount with sum as
      Total,Amount with average as AvgAmt))

  - Name: aliasing - group by and aggregate same property
    Rule: queryOptions
    Input: $apply=groupby((Amount),aggregate(Amount with sum as Total))

  - Name: combining transformations - concat
    Rule: queryOptions
    Input:
      $apply=concat(groupby((Customer/Country,Product/Name,Currency/Code),aggregate(Amount
      with sum as
      Total))/groupby((Customer/Country,Currency/Code),topcount(1,Total)),groupby((Customer/Country,Currency/Code),aggregate(Amount
      with sum as Total)))

  - Name: combining transformations - within groupby
    Rule: queryOptions
    Input:
      $apply=groupby((Customer/Country,Product/Name,Currency/Code),topcount(2,Amount)/aggregate(Amount
      with sum as Total))

  - Name: combining transformations - number of leaves
    Rule: queryOptions
    Input: $apply=groupby((CountryCode),concat(
      groupby((Customer))/aggregate($count as NumberOfLeaves),
      aggregate(Budget,Forecast)
      )/Custom.condense())/orderby(Budget desc)/top(4)

  - Name: combining transformations - number of leaves
    Rule: queryOptions
    Input: $apply=groupby((CountryCode),concat(
      groupby((Customer))/aggregate($count as NumberOfLeaves),
      aggregate(Budget,Forecast)
      )/Custom.condense())/orderby(Budget desc)/top(4)

  - Name: compute
    Rule: queryOptions
    Input: $apply=compute(Amount mul Product/TaxRate as Tax)

  - Name: compute
    Rule: queryOptions
    Input: $apply=compute(Amount mul Product/TaxRate as Tax, day(Time/Date) as
      WeekDay)

  - Name: top
    Rule: queryOptions
    Input: $apply=top(5)

  - Name: skip
    Rule: queryOptions
    Input: $apply=skip(5)

  - Name: orderby
    Rule: queryOptions
    Input: $apply=orderby(Country asc,Name desc)

  - Name: model functions as set transformations
    Rule: queryOptions
    Input:
      $apply=groupby((Customer/Country,Product/Name),aggregate(Amount with sum
      as
      Total))/groupby((Customer/Country),Self.TopCountAndBalance(Count=1,Property='Total'))

  - Name: controlling aggregation - on foot
    Rule: queryOptions
    Input:
      $apply=groupby((Product/ID,Product/Name,Time/Month),aggregate(Amount with
      sum as Total))/groupby((Product/ID,Product/Name),aggregate(Total with
      average as AverageAmount))

  - Name: controlling aggregation - from
    Rule: queryOptions
    Input:
      $apply=groupby((Product/ID,Product/Name),aggregate(Amount with sum from
      Time/Month with average as MonthlyAverage))

  - Name: controlling aggregation - rollup and from
    Rule: queryOptions
    Input:
      $apply=groupby((rollupall(Customer/Country,Customer/ID),Currency/Code),aggregate(Amount
      with sum from Customer/ID with average from Customer/Country with average
      as CustomerCountryAverage))

  - Name: transformation sequences - filter and aggregate
    Rule: queryOptions
    Input: $apply=filter(Amount le 1)/aggregate(Amount with sum as Total)

  - Name: transformation sequences - pre- and post-filter
    Rule: queryOptions
    Input: $apply=filter(Amount le
      2)/groupby((Product/Name),aggregate(Forecast))&$filter=Total ge 4

  - Name: transformation sequences - post-aggregate
    Rule: queryOptions
    Input: $apply=groupby((Time),aggregate(Amount with sum as
      Total))/aggregate(Total with average as DailyAverage)

  - Name: transformation sequences - compute, groupby, and nest
    Rule: queryOptions
    Input: $apply=compute(substring(Name,0,1) as
      FirstLetter)/groupby((FirstLetter),nest(identity as SomeCustomers))

  - Name: transformation sequences - simple
    Rule: queryOptions
    Input:
      $apply=groupby((Continent/Name,Country/Name),aggregate(Population with
      sum as TotalPopulation))

  - Name: transformation sequences - Population 1
    Rule: queryOptions
    Input: $apply=filter(Population ge
      10000000)/groupby((Continent/Name,Country/Name),aggregate(Population with
      sum as TotalPopulation))

  - Name: transformation sequences - Population 2
    Rule: queryOptions
    Input:
      $apply=groupby((Continent/Name,Country/Name),aggregate(Population with
      sum as CountryPopulation))/filter(CountryPopulation ge
      10000000)/concat(identity,groupby((Continent/Name),aggregate(CountryPopulation
      with sum as TotalPopulation)))

  - Name: transformation sequences - Population 3
    Rule: queryOptions
    Input:
      $apply=groupby((Continent/Name,Country/Name),aggregate(Population with
      sum as CountryPopulation))/filter(CountryPopulation ge
      10000000)/groupby((rollup(Continent/Name,Country/Name)),aggregate(CountryPopulation
      with sum as TotalPopulation))

  - Name: transformation sequences - Population 4
    Rule: queryOptions
    Input:
      $apply=groupby((Continent/Name,Country/Name),aggregate(Population with
      sum as CountryPopulation))/concat(filter(CountryPopulation ge
      10000000),groupby((Continent/Name),aggregate(CountryPopulation with sum as
      TotalPopulation)))

  - Name: transformation sequences - filter and nest
    Rule: queryOptions
    Input:
      $apply=filter(Status eq 'incomplete')/transformnested(Items,filter(not
      Shipped))/groupby((Customer/Country),aggregate(Amount with sum as
      ItemAmount))

  - Name: transformation sequences - paging with skip and top
    Rule: queryOptions
    Input: $apply=groupby((Customer/City),aggregate(Amount with sum as
      Total))/skip(10)/top(5)

  - Name: transformation sequences - sorting
    Rule: queryOptions
    Input: $apply=groupby((Product/Name),aggregate(Amount with sum as
      Total))/orderby(Total desc)

  - Name: transformation sequences - joining related instances
    Rule: queryOptions
    Input: $apply=join(Sales as TotalSales,aggregate(Amount with sum as
      Total))/groupby((Name,TotalSales/Total))

  - Name: transformation sequences - joining related instances keeping unrelated ones
    Rule: queryOptions
    Input: $apply=outerjoin(Sales as TotalSales,aggregate(Amount with sum as
      Total))/groupby((Name,TotalSales/Total))

  - Name: transformation sequences - sub-hierarchy selection
    Rule: queryOptions
    Input: $apply=descendants($root/SalesOrganizations,SalesOrgHierarchy,ID,Name eq 'US',keep
      start)/ancestors($root/SalesOrganizations,SalesOrgHierarchy,ID,contains(Name,'East'),keep
      start)/traverse(SalesOrgHierarchy,preorder)

  - Name: transformation sequences - aggregation along hierarchy
    Rule: queryOptions
    Input: $apply=transformnested(Sales,filter(Product/Name eq
      'Paper'))/groupby((rollup(SalesOrgHierarchy)),aggregate(Sales/$count with
      sum as PaperSalesCount))

  - Name: aggregate in $expand
    Rule: odataRelativeUri
    Input: Categories?$expand=Products($apply=aggregate(Price with average as
      AveragePrice))
