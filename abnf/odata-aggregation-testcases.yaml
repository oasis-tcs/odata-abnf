#  OData Aggregation ABNF Test Cases Version 4.0
#
#  Working Draft 04
#  04 November 2015
#
#  Technical Committee:
#  OASIS Open Data Protocol (OData) TC
#  https://www.oasis-open.org/committees/odata
#
#  Chairs:
#  - Barbara Hartel (barbara.hartel@sap.com), SAP AG
#  - Ram Jeyaraman (Ram.Jeyaraman@microsoft.com), Microsoft
#
#  Editors:
#  - Ralf Handl (ralf.handl@sap.com), SAP AG
#  - Hubert Heijkers (hubert.heijkers@nl.ibm.com), IBM
#  - Gerald Krause (gerald.krause@sap.com), SAP AG
#  - Michael Pizzo (mikep@microsoft.com), Microsoft
#  - Martin Zurmuehl (martin.zurmuehl@sap.com), SAP AG
#
#  Additional artifacts:
#  This test case document is one component of a Work Product which consists of:
#  - OData Extension for Data Aggregation Version 4.0
#  - OData Aggregation ABNF Construction Rules Version 4.0
#  - OData Aggregation ABNF Test Cases
#  - OData Aggregation Vocabulary
#
#  Related work:
#  This specification is related to:
#  - OData Version 4.0 Part 1: Protocol
#  - OData Version 4.0 Part 2: URL Conventions
#  - OData Version 4.0 Part 3: CSDL
#  - OData ABNF Construction Rules Version 4.0
#  - OData Core Vocabulary
#  - OData Measures Vocabulary
#  - OData JSON Format Version 4.0
#  This specification replaces or supersedes:
#  - None
#
#  Declared XML namespaces:
#  - None
#
#  Abstract:
#  This specification adds basic grouping and aggregation functionality (e.g.
#  sum, min, and max) to the Open Data Protocol (OData) without changing any
#  of the base principles of OData.
#
#
#  Overview:
#  This document contains positive and negative test cases for the
#  OData Aggregation ABNF Construction Rules Version 4.0.
#  Positive test cases consist of the rule to test, the input string to parse,
#  and a description of the test case.
#  Negative test cases in addition state the character position at which the
#  invalid portion of input text starts, 0 meaning the whole input string.
#
#  These test cases can be automatically executed with the ABNF test tool
#  available at https://github.com/oasis-tcs/odata-abnf/tree/main/lib.
#  This tool is neither required for interpreting the test cases, nor is it
#  part of the OData work product.

Constraints:
  action: []
  actionImport: []
  expressionAlias:
    - Actual
    - AverageAmount
    - AveragePrice
    - AvgAmt
    - CountryPopulation
    - CustomerCountryAverage
    - DailyAverage
    - DistinctProducts
    - ItemAmount
    - MaxAmount
    - MinAmount
    - MonthlyAverage
    - ProductNames
    - Profit
    - SalesCount
    - Tax
    - Total
    - TotalPlannedRevenue
    - TotalPopulation
    - WeekDay
  complexColProperty:
    - Details
  complexColFunction: []
  complexColFunctionImport: []
  complexFunction: []
  complexFunctionImport: []
  complexProperty:
    - ShipTo
  complexTypeName: []
  customAggregate:
    - Budget
    - Forecast
  entityColFunction:
    - TopCountAndBalance
  entityColFunctionImport: []
  entityColNavigationProperty:
    - Items
    - Orders
    - Products
    - Sales
    - SalesPlan
    - Suppliers
  entityFunction: []
  entityFunctionImport: []
  entityNavigationProperty:
    - Category
    - Continent
    - Country
    - Currency
    - Customer
    - Product
    - Products_cj
    - ProductGroup
    - Sales_cj
    - Time
  entitySetName:
    - Categories
    - Customers
    - Products
    - Products_cj
    - Sales
    - Sales_cj
    - SalesOrganizations
    - Time
  entityTypeName: []
  enumerationMember: []
  enumerationTypeName: []
  keyPathLiteral: []
  keyPropertyAlias: []
  lambdaVariableExpr: []
  namespacePart:
    - Aggregation
    - Custom
    - Self
  primitiveColFunction: []
  primitiveColFunctionImport: []
  primitiveColProperty: []
  primitiveFunction:
    - isroot
    - isleaf
    - isancestor
    - issibling
    - isdescendant
  primitiveFunctionImport: []
  primitiveKeyProperty:
    - Code
    - Date
    - ID
  primitiveNonKeyProperty:
    - Amount
    - City
    - Cost
    - CountryCode
    - Month
    - Name
    - PlannedRevenue
    - Population
    - Price
    - ProductID
    - Quantity
    - Revenue
    - SalesArea
    - Shipped
    - Status
    - Street
    - TaxRate
    - Year
  streamProperty: []

TestCases:
  - Name: aggregate - no parameters
    Rule: queryOptions
    FailAt: 17
    Input: $apply=aggregate()

  - Name: aggregate - property with method as alias
    Rule: queryOptions
    Input: $apply=aggregate(Amount with sum as Total)

  - Name: aggregate - alias - context URL
    Rule: odataRelativeUri
    Input: $metadata#Sales(Total)

  - Name: aggregate - property requires alias
    Rule: queryOptions
    FailAt: 32
    Input: $apply=aggregate(Amount with sum)

  - Name: aggregate - property requires method
    Rule: queryOptions
    FailAt: 24
    Input: $apply=aggregate(Amount as Total)

  - Name: aggregate - property requires alias
    Rule: queryOptions
    FailAt: 32
    Input: $apply=aggregate(Amount with sum)

  - Name: aggregate - property requires method and alias
    Rule: queryOptions
    FailAt: 23
    Input: $apply=aggregate(Amount)

  - Name: aggregate - expression
    Rule: queryOptions
    Input: $apply=aggregate(Amount mul Product/TaxRate with sum as Tax)

  - Name: aggregate - expression after path
    Rule: queryOptions
    Input: $apply=aggregate(Sales(Amount mul Product/TaxRate with sum as Tax))

  - Name: aggregate - alias - context URL
    Rule: odataRelativeUri
    Input: $metadata#Products(Sales(Tax))

  - Name: aggregate - min
    Rule: queryOptions
    Input: $apply=aggregate(Amount with max as MaxAmount)

  - Name: aggregate - max
    Rule: queryOptions
    Input: $apply=aggregate(Amount with max as MaxAmount)

  - Name: aggregate - average
    Rule: queryOptions
    Input: $apply=aggregate(Amount with average as AverageAmount)

  - Name: aggregate - custom aggregation method
    Rule: queryOptions
    Input: $apply=aggregate(Product/Name with Custom.concat as ProductNames)

  - Name: aggregate - countdistinct
    Rule: queryOptions
    Input: $apply=aggregate(Product with countdistinct as DistinctProducts)

  - Name: aggregate - from
    Rule: queryOptions
    Input: $apply=aggregate(Amount with sum from Time with average as DailyAverage)

  - Name: aggregate - from twice
    Rule: queryOptions
    Input:
      $apply=aggregate(Amount with sum from Time with average from Product/Name
      with max as DailyAverage)

  - Name: aggregate - from requires as
    Rule: queryOptions
    FailAt: 55
    Input: $apply=aggregate(Amount with sum from Time with average)

  - Name: aggregate - property from requires with
    Rule: queryOptions
    FailAt: 24
    Input: $apply=aggregate(Amount from Time with average as DailyAverage)

  - Name: aggregate - custom aggregate and from
    Rule: queryOptions
    Input: $apply=aggregate(Forecast from Time with average as DailyAverage)

  - Name: aggregate - path with key segment
    Rule: queryOptions
    Input: $apply=aggregate(Product/SalesPlan('2015')/PlannedRevenue with sum as
      TotalPlannedRevenue)

  - Name: Aggregation - collection of complex type
    Rule: queryOptions
    Input: $apply=groupby((Product),aggregate(Details(Amount with sum as Total)))

  - Name: aggregate - $count
    Rule: queryOptions
    Input: $apply=aggregate($count as SalesCount)

  - Name: aggregate - $count does not allow with
    Rule: queryOptions
    FailAt: 24
    Input: $apply=aggregate($count with sum as SalesCount)

  - Name: aggregate - topcount
    Rule: queryOptions
    Input: $apply=topcount(2,Amount)

  - Name: aggregate - topsum
    Rule: queryOptions
    Input: $apply=topsum(15,Amount)

  - Name: aggregate - toppercent
    Rule: queryOptions
    Input: $apply=toppercent(50,Amount)

  - Name: aggregate - bottomcount
    Rule: queryOptions
    Input: $apply=bottomcount(2,Amount)

  - Name: aggregate - bottomsum
    Rule: queryOptions
    Input: $apply=bottomsum(15,Amount)

  - Name: aggregate - bottompercent
    Rule: queryOptions
    Input: $apply=bottompercent(50,Amount)

  - Name: aggregate - identity
    Rule: queryOptions
    Input: $apply=identity

  - Name: aggregate - concat
    Rule: queryOptions
    Input: $apply=concat(topcount(2,Amount),bottomcount(2,Amount))

  - Name: aggregate - groupby
    Rule: queryOptions
    Input:
      $apply=groupby((Customer/Country,Product/Name),aggregate(Amount with sum
      as Total))

  - Name: aggregate - groupby distinct
    Rule: queryOptions
    Input: $apply=groupby((Product/Name,Amount))

  - Name: aggregate - groupby rollup
    Rule: queryOptions
    Input:
      $apply=groupby((rollup(Customer/Country,Customer/Name),rollup(Product/ProductGroup/Name,Product/Name),Currency/Code),aggregate(Amount
      with sum as Total))

  - Name: aggregate - filter
    Rule: queryOptions
    Input: $apply=filter(Amount gt 3)

  - Name: aggregate - expand
    Rule: queryOptions
    Input: $apply=expand(Sales,filter(Amount gt 3))

  - Name: aggregate - multi-level expand
    Rule: queryOptions
    Input: $apply=expand(Products,expand(Sales,filter(Amount gt 3)))

  - Name: aggregate - multi-level expand with branches
    Rule: queryOptions
    Input: $apply=expand(Products,expand(Sales,filter(Amount gt
      3)),expand(Suppliers,expand(Products,filter(true))))

  - Name: aggregate - multi-level expand with branches
    Rule: queryOptions
    FailAt: 102
    Input: $apply=expand(Products,expand(Sales,filter(Amount gt
      3)),expand(Suppliers,filter(true),expand(Products)))

  - Name: aggregate - multi-level expand with branches
    Rule: queryOptions
    FailAt: 89
    Input: $apply=expand(Products,expand(Sales,filter(Amount gt
      3)),expand(Suppliers,expand(Products)))

  - Name: aggregate - expand with filter on $this
    Rule: queryOptions
    Input: $apply=expand(Sales,filter($this/Customer/City eq ShipTo/City))

  - Name: aggregate - expand with filter on $root
    Rule: queryOptions
    Input: $apply=filter(Name eq $root/Products('P2')/Name)

  - Name: aggregate - search
    Rule: queryOptions
    Input: $apply=search(coffee)

  - Name: aggregate - isdefined
    Rule: queryOptions
    Input: $filter=isdefined(Product) and isdefined(Customer/Name) and
      isdefined(Forecast)

  - Name: "aggregate - isdefined: get totals last"
    Rule: queryOptions
    Input: $orderby=isdefined(Product) desc,Product asc

  - Name: aggregate - crossjoin
    Rule: odataRelativeUri
    Input: $crossjoin(Products_cj,Sales_cj)?$apply=filter(Products_cj/ID eq
      Sales_cj/ProductID)/groupby((Products_cj/Name),aggregate(Sales_cj/Amount
      with sum as Total))

  - Name: aggregate - crossjoin
    Rule: odataRelativeUri
    Input: $crossjoin(Products_cj,Time,Sales_cj)?$apply=groupby((Products_cj/Name,Time/Date),aggregate(Budget))

  - Name: aggregate - custom aggregate with path on crossjoin
    Rule: odataRelativeUri
    Input: $crossjoin(Products_cj,Time,Sales_cj)?$apply=groupby((Products_cj/Name,Time/Date),aggregate(Sales_cj/Forecast))

  - Name: custom aggregates - entity set
    Rule: odataRelativeUri
    Input: Sales?$apply=groupby((Time/Month),aggregate(Forecast))

  - Name: custom aggregates - crossjoin
    Rule: odataRelativeUri
    Input: $crossjoin(Time)?$apply=groupby((Time/Year),aggregate(Budget))

  - Name: hierarchy functions - isroot
    Rule: odataRelativeUri
    Input: SalesOrganizations?$filter=$it/Aggregation.isroot(Hierarchy='SalesOrgHierarchy')

  - Name: hierarchy functions - isdescendant
    Rule: odataRelativeUri
    Input: SalesOrganizations?$filter=$it/Aggregation.isdescendant(Hierarchy='SalesOrgHierarchy',Node='EMEA')

  - Name: hierarchy functions - isdescendant
    Rule: odataRelativeUri
    Input: SalesOrganizations?$filter=$it/Aggregation.isdescendant(Hierarchy='SalesOrgHierarchy',Node='EMEA',MaxDistance=1)

  - Name: hierarchy functions - isancestor
    Rule: odataRelativeUri
    Input: SalesOrganizations?$filter=$it/Aggregation.isancestor(Hierarchy='SalesOrgHierarchy',Node='EMEA')

  - Name: hierarchy functions - isancestor
    Rule: odataRelativeUri
    Input: SalesOrganizations?$filter=$it/Aggregation.isancestor(Hierarchy='SalesOrgHierarchy',Node='EMEA',MaxDistance=1)

  - Name: hierarchy functions - issibling
    Rule: odataRelativeUri
    Input: SalesOrganizations?$filter=$it/Aggregation.issibling(Hierarchy='SalesOrgHierarchy',Node='EMEA')

  - Name: hierarchy functions - isleaf
    Rule: odataRelativeUri
    Input: SalesOrganizations?$filter=$it/Aggregation.isleaf(Hierarchy='SalesOrgHierarchy')

  - Name: distinct values - no aggregate
    Rule: odataRelativeUri
    Input: Customers?$apply=groupby((Name))

  - Name: distinct values - navigation
    Rule: queryOptions
    Input: $apply=groupby((Customer/Name))

  - Name: distinct values - two grouping properties
    Rule: queryOptions
    Input: $apply=groupby((Customer/Name,Customer/ID))

  - Name: distinct values - three grouping properties
    Rule: queryOptions
    Input: $apply=groupby((Customer/Name,Customer/ID,Product/Name))

  - Name: aggregation methods
    Rule: queryOptions
    Input: $apply=groupby((Name),aggregate(Sales(Amount with sum as Total)))

  - Name: aggregation methods - multiple grouping
    Rule: queryOptions
    Input:
      $apply=groupby((Name,Sales/Currency/Code),aggregate(Sales(Amount with sum
      as Total)))

  - Name: aggregation methods - multiple grouping - distinct
    Rule: queryOptions
    Input: $apply=groupby((Country,Sales/Product/Name))

  - Name: aggregation methods - average
    Rule: queryOptions
    Input: $apply=groupby((Customer/Country),aggregate(Amount with average as
      AverageAmount))

  - Name: aggregation methods - $count segment
    Rule: queryOptions
    Input: $apply=groupby((Name),aggregate(Sales/$count with sum as SalesCount))

  - Name: aggregation methods - $count segment and sum
    Rule: queryOptions
    Input: $apply=groupby((Name),aggregate(Sales/$count with sum as
      SalesCount,Sales(Amount with sum as Total)))

  - Name:
      aggregation methods - $count only allowed on top level, not nested within
      path
    Rule: queryOptions
    FailAt: 38
    Input:
      $apply=groupby((Name),aggregate(Sales($count as SalesCount),Sales(Amount
      with sum as Total)))

  - Name: collection-valued path
    Rule: queryOptions
    Input: $apply=groupby((Name),aggregate(Sales/Amount with sum as Total))

  - Name: custom aggregate
    Rule: queryOptions
    Input: $apply=groupby((Customer/Country),aggregate(Amount with sum as
      Actual,Forecast))

  - Name: custom aggregate - with path
    Rule: queryOptions
    Input: $apply=groupby((Name),aggregate(Sales(Amount with sum as
      Actual),Sales/Forecast))

  - Name: aliasing - aggregate with two parameters
    Rule: queryOptions
    Input: $apply=groupby((Customer/Country),aggregate(Amount with sum as
      Total,Amount with average as AvgAmt))

  - Name: aliasing - two parameters with path
    Rule: queryOptions
    Input: $apply=groupby((Name),aggregate(Sales(Amount with sum as
      Total),Sales(Amount with average as AvgAmt)))

  - Name: aliasing - group by and aggregate same property
    Rule: queryOptions
    Input: $apply=groupby((Amount),aggregate(Amount with sum as Total))

  - Name: combining transformations - concat
    Rule: queryOptions
    Input:
      $apply=concat(groupby((Customer/Country,Product/Name,Currency/Code),aggregate(Amount
      with sum as
      Total))/groupby((Customer/Country,Currency/Code),topcount(1,Total)),groupby((Customer/Country,Currency/Code),aggregate(Amount
      with sum as Total)))

  - Name: combining transformations - within groupby
    Rule: queryOptions
    Input:
      $apply=groupby((Customer/Country,Product/Name,Currency/Code),topcount(2,Amount)/aggregate(Amount
      with sum as Total))

  - Name: compute
    Rule: queryOptions
    Input: $apply=compute(Amount mul Product/TaxRate as Tax)

  - Name: compute
    Rule: queryOptions
    Input: $apply=compute(Amount mul Product/TaxRate as Tax, day(Time/Date) as
      WeekDay)

  - Name: model functions as set transformations
    Rule: queryOptions
    Input:
      $apply=groupby((Customer/Country,Product/Name),aggregate(Amount with sum
      as
      Total))/groupby((Customer/Country),Self.TopCountAndBalance(Count=1,Property='Total'))

  - Name: controlling aggregation - on foot
    Rule: queryOptions
    Input:
      $apply=groupby((Product/ID,Product/Name,Time/Month),aggregate(Amount with
      sum as Total))/groupby((Product/ID,Product/Name),aggregate(Total with
      average as AverageAmount))

  - Name: controlling aggregation - from
    Rule: queryOptions
    Input:
      $apply=groupby((Product/ID,Product/Name),aggregate(Amount with sum from
      Time/Month with average as MonthlyAverage))

  - Name: controlling aggregation - rollup and from
    Rule: queryOptions
    Input:
      $apply=groupby((rollup($all,Customer/Country,Customer/ID),Currency/Code),aggregate(Amount
      with sum from Customer/ID with average from Customer/Country with average
      as CustomerCountryAverage))

  - Name: transformation sequences - filter and aggregate
    Rule: queryOptions
    Input: $apply=filter(Amount le 1)/aggregate(Amount with sum as Total)

  - Name: transformation sequences - pre- and post-filter
    Rule: queryOptions
    Input: $apply=filter(Amount le
      2)/groupby((Product/Name),aggregate(Forecast))&$filter=Total ge 4

  - Name: transformation sequences - post-aggregate
    Rule: queryOptions
    Input: $apply=groupby((Time),aggregate(Amount with sum as
      Total))/aggregate(Total with average as DailyAverage)

  - Name: transformation sequences - simple
    Rule: queryOptions
    Input:
      $apply=groupby((Continent/Name,Country/Name),aggregate(Population with
      sum as TotalPopulation))

  - Name: transformation sequences - Population 1
    Rule: queryOptions
    Input: $apply=filter(Population ge
      10000000)/groupby((Continent/Name,Country/Name),aggregate(Population with
      sum as TotalPopulation))

  - Name: transformation sequences - Population 2
    Rule: queryOptions
    Input:
      $apply=groupby((Continent/Name,Country/Name),aggregate(Population with
      sum as CountryPopulation))/filter(CountryPopulation ge
      10000000)/concat(identity,groupby((Continent/Name),aggregate(CountryPopulation
      with sum as TotalPopulation)))

  - Name: transformation sequences - Population 3
    Rule: queryOptions
    Input:
      $apply=groupby((Continent/Name,Country/Name),aggregate(Population with
      sum as CountryPopulation))/filter(CountryPopulation ge
      10000000)/groupby((rollup(Continent/Name,Country/Name)),aggregate(CountryPopulation
      with sum as TotalPopulation))

  - Name: transformation sequences - Population 4
    Rule: queryOptions
    Input:
      $apply=groupby((Continent/Name,Country/Name),aggregate(Population with
      sum as CountryPopulation))/concat(filter(CountryPopulation ge
      10000000),groupby((Continent/Name),aggregate(CountryPopulation with sum as
      TotalPopulation)))

  - Name: transformation sequences - filter and expand
    Rule: queryOptions
    Input: $apply=filter(Status eq 'incomplete')/expand(Items,filter(not
      Shipped))/groupby((Customer/Country),aggregate(Items(Amount with sum as
      ItemAmount)))

  - Name: aggregate in $expand
    Rule: odataRelativeUri
    Input: Categories?$expand=Products($apply=aggregate(Price with average as
      AveragePrice))
